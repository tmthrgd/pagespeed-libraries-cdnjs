// Because sometimes you need to mark the selected *text*.
//
// Adds an option 'styleSelectedText' which, when enabled, gives
// selected text the CSS class given as option value, or
// "CodeMirror-selectedtext" when the value is not a string.
(function(){"use strict";function e(e){e.operation(function(){a(e)})}function t(e){e.state.markedSelection.length&&e.operation(function(){o(e)})}function i(e,t){return e.line-t.line||e.ch-t.ch}function s(e,t,s,o){if(i(t,s)==0)return;var u=e.state.markedSelection,a=e.state.markedSelectionStyle;for(var f=t.line;;){var l=f==t.line?t:r(f,0),c=f+n,h=c>=s.line,p=h?s:r(c,0),d=e.markText(l,p,{className:a});o==null?u.push(d):u.splice(o++,0,d);if(h)break;f=c}}function o(e){var t=e.state.markedSelection;for(var n=0;n<t.length;++n)t[n].clear();t.length=0}function u(e){o(e);var t=e.getCursor("start"),n=e.getCursor("end");s(e,t,n)}function a(e){var t=e.getCursor("start"),r=e.getCursor("end");if(i(t,r)==0)return o(e);var a=e.state.markedSelection;if(!a.length)return s(e,t,r);var f=a[0].find(),l=a[a.length-1].find();if(!f||!l||r.line-t.line<n||i(t,l.to)>=0||i(r,f.from)<=0)return u(e);while(i(t,f.from)>0)a.shift().clear(),f=a[0].find();i(t,f.from)<0&&(f.to.line-t.line<n?(a.shift().clear(),s(e,t,f.to,0)):s(e,t,f.from,0));while(i(r,l.to)<0)a.pop().clear(),l=a[a.length-1].find();i(r,l.to)>0&&(r.line-l.from.line<n?(a.pop().clear(),s(e,l.from,r)):s(e,l.to,r))}CodeMirror.defineOption("styleSelectedText",!1,function(n,r,i){var s=i&&i!=CodeMirror.Init;r&&!s?(n.state.markedSelection=[],n.state.markedSelectionStyle=typeof r=="string"?r:"CodeMirror-selectedtext",u(n),n.on("cursorActivity",e),n.on("change",t)):!r&&s&&(n.off("cursorActivity",e),n.off("change",t),o(n),n.state.markedSelection=n.state.markedSelectionStyle=null)});var n=8,r=CodeMirror.Pos})();